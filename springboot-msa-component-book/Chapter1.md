## 1.1 모놀리식 아키텍처 소개

- 마이크로 서비스는 작은 단위의 컴포넌트로 구성 됨
- 모놀리식 아키텍처는 하나의 시스템이 서비스 전체 기능을 처리하도록 설계한 것

### 1.1.1 모놀리식 아키텍처의 장점

- 간단한 구조로 이루어져있어 시스템 운영과 개발이 편리
- 네트워크로 인한 지연이나 데이터 유실은 걱정할 필요가 없음
- 시스템 장애나 기능에 버그가 있으면 하나의 애플리케이션을 통해 파악 가능
- 트랜잭션을 쉽게 사용 가능하여 데이터의 일관성 유지 가능

### 1.1.2 모놀리식 아키텍처의 단점

- JSP나 Thymeleaf와 같은 템플릿 엔진을 사용하는 경우 클라이언트와 서버의 코드가 한 애플리케이션안에 담김
- 고가용성 HA를 확보하기 위해 스케일 아웃을 하게되는데, 스케일 아웃시 특정 기능에 대한 스케일 아웃이 아닌 전체 기능에 대한 스케일 아웃이어서 효과적이지 않음
- 기능이 많아질 수록 개발 속도나 생산성이 낮아짐

**전환 고려 사항(3개 이상시)**

1. 클라이언트 요청이 점점 많아지는데 로드 밸런서로 확장해도 한계가 있을 때
2. 데이터베이스 성능을 높여도 더 이상 성능 개선의 여지가 없을 때
3. 기능 확장 요구가 많지만 현재 시스템 구조로 불가능할 때
4. 소스 코드가 너무 복잡해서 리팩터링이 필요할 때
5. 기능 중 하나라도 변경되면 QA를 해야할 때
6. 기능을 수정하면 다른 기능에 연쇄적으로 버그가 발생할 때
7. 개발자는 늘었는데, 개발 속도는 이전 같지 않을 때

## 1.2 마이크로아키텍처 서비스 소개

- 마이크로서비스는 SOA와 지향하는바가 비슷함
- 마이크로서비스들은 독립적으로 동작해야하고, 의존하는 경우 장애가 전파될 수 있음
- 각 컴포넌트들은 통신할 때 API를 통해 서로 데이터를 주고 받음 → 네트워크 프로토콜이 성능 저하의 원인 가능성
- 보통 HTTP REST-API를 이용하여 JSON 형식으로 교환하는 경우가 많고 gRPC나 ProtoBuffer등도 사용
- 비동기 처리를 위해 AMQP 프로토콜을 사용하는 메세징 큐 시스템 기반으로 동작하기도 함
    - 메시지 큐를 이용하게될 경우 마이크로서비스 사이에 메시징 큐 시스템에 의존성이 생김

### 1.2.1 마이크로서비스의 장점

1. 독립성
    - 하나의 비즈니스 기능을 담당하므로 다른 마이크로서비스와 간섭이 최소화
    - 독립된 데이터 저장소를 가지고 있으므로 데이터 간섭에도 자유로움
2. 대용량 데이터를 저장하고 처리하는데 자유로움
    - 대부분 웹 서비스는 데이터를 저장하기 위해 RDB나 NoSQL에 저장
    - RDB는 스케일 아웃이 쉽지 않기도하고, NoSQL도 스케일 아웃시 발생할 수 있는 CPU 문제나 리밸런싱 문제가 있음
        - 이러한 문제들을 마이크로서비스에서는 애초에 데이터를 따로 저장하니까 효과적임
3. 시스템 장애에 견고함
    - 서로 느슨하게 결합되어있고 각각 독립되어있어서 서로 간에 미치는 영향이 적음
    - **탄력회복성**
        - 애플리케이션 서버에 장애가 발생하면 새로운 컴퓨팅 자원을 추가하여 빠른 시간안에 서비스를 다시 제공하는 것을 의미
4. 서비스 배포 주기가 빠름
    - 모놀리식의 경우 하나의 코드베이스에서 개발 됨 → 그 기간동안 발생된 개발 코드를 한꺼번에 모아서 배포
    - 모든 기능이 분리되어있어서 필요한 기능만 먼저 개별적으로 배포 가능
5. 확장성에 강함
6. 사용자 반응에 민첩하게 대응 가능
    - 특정 서비스만 격리시키거나 고도화 시키기 좋음

### 1.2.2 마이크로서비스 단점

1. 개발하기 어려운 아키텍처
    - 분리된 데이터, 네트워크를 통한 데이터 통합
    - 트랜잭션 문제 → 분산 트랜잭션은 시스템 전체의 리소스를 많이 사용해서 권장하지 않음
        - 중복된 데이터가 발생하여 정합성이 맞지 않을 수 있음
    - 장애시 장애 전환에 대한 폴백 기능을 고려해야함
2. 운영하기 매우 어려운 아키텍처
    - 하나의 비즈니스 로직을 철하기 위해 많은 마이크로서비스들이 통합되어야 함
    - 요청이 정상적으로 처리되지 않으면 어디서 문제가 발생했는지 찾기 어려움
    - 데이터가 분산되어 있어서 분산 트랜잭션을 사용하지 않으면 데이터 일관성 유지에 어려움
        - 원상 복구를 위해 스케줄링 프로세스나 상태 머신과 흡사한 사카 패턴을 이용해서 데이터를 지우거나 실패내역을 사용자에게 알려줘야 함
3. 설계하기 어려운 아키텍처
    - 잘못된 방향으로 설계하면 오히려 유지 보수시간이 더 오래걸림
    - 데이터의 중복성을 방지하기도 어려움
    - 규모가 커지면 다시 쪼개야하는 문제들도 생김
4. 여러가지 자동화된 시스템이 필요함
5. 개발자의 기술력이 좋아야 함

## 1.3 마이크로서비스 아키텍처 설계

잘 분리된 마이크로서비스는 각 개념이 서로 겹치지않고 독립적으로 서비스되는 것을 의미

아래는 잘 분리된 마이크로서비스를 위해 소개할만한 원칙

### 1.3.1 서비스 세분화 원칙

1. 비즈니스 기능
    - 비즈니스 기능으로 서비스를 나눔
2. 성능
    - 성능이 떨어지는 마이크로서비스가 너무 많은 기능을 처리하고 있지 않은지 파악해서 나누는 것도 고려해보기
3. 메시지 크기
    - API를 설계하는데 메시지 크기가 크다면 마이크로서비스를 나누는 것을 고려
4. 트랜잭션
    - 데이터 정합성을 유지하는 트랜잭션으로 서비스를 나누는 것도 좋음

### 1.3.2 도메인 주도 설계의 바운디드 컨텍스트

- 도메인 모델이 존재하는 다른 도메인 모델과 확연히 구분되는 명시적인 경계를 바운디드 컨텍스트라고 함

### 1.3.3 단일 책임 원칙

- 모든 클래스는 하나의 책임을 가지는 단일 책임 원칙을 따름
- 응집도를 높이고 결합도를 낮추는 방법

### 1.3.4 가벼운 통신 프로토콜

- 네트워크 지연이나 직렬화/역직렬화에 대한 부담이 큼
- 마이크로서비스 사이에 네트워크 통신은 항상 가벼워야하며, 특정 기술이나 언어에 의존성이 없어야 함

### 1.3.5 외부 인터페이스 공개

- 한번 공개된 인터페이스는 기존 버전에 의존적인 시스템들이 많기에 버전으로 나누어서 관리해야 함

### 1.3.6 독립된 데이터 저장소

- 마이크로서비스는 항상 독립된 데이터 저장소를 이용한다.

## 1.4 아키텍처 변화

### 1.4.1 모놀리식 아키텍처 선택

- 초기 아키텍처를 모놀리식 아케틱처로 선택
- SpringBoot와 Java, MySQL을 이용 HTML, CSS, JAVASCRIPT도 WAS에서 처리

### 1.4.2 서비스 안정성 확보

- 트래픽이 많아짐에 따라 배포할 때 서비스 중단, WAS의 장애 발생
- HA 고가용성을 선택
    - 일반적으로 고가용성을 위해서는 로드밸런서를 이용해서 처리
    - 요청량 변화에 따라 애플리케이션 서버를 늘리는 것을 스케일 아웃이라고 함
- 하지만 데이터 저장소도 단일 장애점이 되므로 MMM 방식을 이용하여 Replication을 진행

### 1.4.3 확장의 시작

- 모니터링 도입 후 애플리케이션 서버가 너무 많은 일, 너무 많은 기능을 하고 있는 것을 깨달음
- 스케일 아웃하는 것은 비효율적, 기능에 따라 시스템을 확장하기로 함
- HTTPS 인증서 처리와 정적 컨텐츠 처리는 웹서버를 별도로 두어 해당하는 곳에서 처리하도록 개선
- 프론트엔드 백엔드 분리, CDN 환경 고려

### 1.4.4 데이터 저장소의 확장

- MySQL의 경우 인스턴스가 여러개로 분리되면 수평적으로 확장되어 트랜잭션 기능을 사용하기 어려움 → 분산 트랜잭션은 가능 함
- 그치만 수직 확장의 경우 한계가 명확함
- 테이블 파티셔닝, 쿼리 튜닝, 테이블 비정규화 등 수많은 성능 튜닝 방법을 써야 함
    - 인스턴스 내에서 성능을 높이는 것
- 샤딩 기법을 이용하여 데이터들을 샤드라는 단위로 여러 데이터베이스 인스턴스에 나누어 관리
    - 데이터를 분류하는 기준이 핵심 알고리즘
    - 각 샤드는 HA를 위해 Master-Slave로 동작해야 함
    - 분류 설정 알고리즘이 특정 샤드에 몰릴 경우 똑같이 부하를 받아서 소용이 없을 수도 있음
- 로케이션 서비스 방식
    - 데이터 위치를 중앙에서 관리
    - Select하기 위해 로케이션 서비스에 질의
    - 로케이션 서비스가 요청한 정보는 샤드 1에 있다고 응답
    - 애플리케이션 서버가 샤드 1의 데이터베이스 인스턴스에 질의
    - 약간 API Gateway 느낌인 것 같기도?
    - 로케이션 서비스도 사실 트래픽이 몰리는 단일장애점이 될 수 있고 몰리면 몰릴 수록 응답 시간이 느려져서 경량화된 네트워크 통신을 이용해야 함
    - 로케이션 서비스를 이용하면 리밸런싱 작업에 유리
- 샤딩의 단점
    - 분산 트랜잭션을 이용하지 않을 경우 하나의 샤드에서만 트랜잭션 적용 가능
    - 네트워크 및 시스템 리소스 사용 비용이 높아 잘 사용하지 않음
    - 여러 샤드에 걸친 Join 쿼리 사용 불가능
    - 테이블 설정 변경시 모든 샤드에 적용 필요
    - Global UUID 값으로 설정 필요 → 모든 샤드에 Auto Increment가 적용되지 않음

### 1.4.5 마이크로서비스 아키텍처의 시작

- 모놀리식의 아키텍처는 오히려 생산성이 예전보다 느려짐 → 마이크로서비스 아키텍처로 변경하기로 결정
    - 애플리케이션의 복잡도를 낮추지는 못함
    - 여러 기능들이 담긴 모놀리식에서 수정할 경우 같은 클래스를 수정할 수도 있음
    - 배포 주기에도 영향을 줌
    - 샤딩 운영의 어려움
- 서비스 전체 기능을 분류하기 시작
    - 독립성을 가질 수 있는지 없는지에 대한 구분

## 1.5 12요소 애플리케이션

- 마이크로서비스의 경우 클라우드를 선호
- 클라우드 환경에 적합한 유연한 애플리케이션을 개발하는 방법론이 12 요소 애플리케이션임
    - Heroku에서 제안한 설계 방법

### 1.5.1 코드베이스: 버전 관리되는 하나의 코드베이스와 다양한 배포

- 프로젝트에 담긴 코드들을 코드베이스라고 함
- 코드베이스를 관리하는 툴을 사용해야하고, 여러 환경에서 동작할 수 있도록 함(local, dev, prod)

### 1.5.2 의존성: 명시적으로 선언할 수 있고 분리할 수 있는 의존성

- build.gradle이나 pom.xml로 외부 라이브러리 들을 관리

### 1.5.3 설정: 환경 변수를 이용한 설정

- 여러 환경에서 동작할 수 있음 (local, dev, prod)
- 환경변수를 이용하여 프로파일 기능을 사용

### 1.5.4 지원 서비스: 지원 서비스는 연결된 리소스로 처리

- 애플리케이션이 네트워크를 이용해서 사용하는 모든 서비스를 의미
- JDBC로 연결된 MySQL, MongoDB 같은 데이터 저장소나 결제 시스템 영역을 지원 서비스라 함
- RestTemplate과 WebClient클래스 제공

### 1.5.5 빌드, 릴리스, 실행: 소스 빌드와 실행은 완전히 분리되어야 한다.

- 코드베이스는 빌드, 릴리스, 실행 과정으로 배포 됨
- 의존성이 있는 라이브러리와 빌드 함
- 릴리즈 단계는 프로파일 설정을 통해 JAR 파일을 생성
- JAR 파일을 실행

### 1.5.6 프로세스: 애플리케이션은 하나 이상의 무상태 프로세스로 실행되어야 한다.

- 상태를 가지고 있거나 공유하는 것이 없어야 함
- 로드 밸런서를 통해 상태를 저장하고, 다른 서버로 접근시 상태에 대한 값을 받아올 수 없게 됨
- 상태를 저장해야한다면 DBMS와 같은 지원 서비스에 저장해야 함

### 1.5.7 포트 바인딩: 포트 바인딩을 통한 서비스 공개

- 클라우드 환경에서 모든 애플리케이션은 특정 포트가 바인딩되도록 설계
- Nginx나 Apache와 같은 웹 서버들이 80 요청으로 처리하고 보통 리버스 프록시 설정을 통해 애플리케이션 서버로 요청을 포트포워딩 처리 함
    - 외부 공격의 보호를 위해

### 1.5.8 동시성: 프로세스들을 통한 수평 확장

- 클라우드 환경에서는 작은 크기의 애플리케이션을 스케일아웃하는 것을 추천
- 클라우드 환경에서는 스레드 프로그래밍 외에도 프로세스를 이용해서 동시성을 관리

### 1.5.9 폐기 가능: 프로세스는 빠르게 시작해야하고 안정적으로 종료해야 함

- 복원 력이 있는 형태로 설계되어야 함
- 과부화 또는 문제 발생시 스케일 아웃 또는 대처 방안이 있어야 함
- 프로세스의 부팅 속도가 빨라야함
- 안정적으로 종료가 가능하도록 설계
    - DB 커넥션 풀과 같은 것들이 제대로 끊어지지 않으면 지원 서비스에서는 그대로 남아있음

### 1.5.10 Dev 환경과 Production 환경 일치

- Dev와 Production 환경은 최대한 비슷하게 설정하고 유지해야 함
- 다르면 QA 결과가 달라질 수 있음

### 1.5.11 로그: 로그는 이벤트 스트림으로 다룸

- 로그는 이벤트가 시간 순서대로 정렬되어 있으므로 스트림이라고 표현 함. 일반적으로 파일로 저장 됨
    - Dev환경은 파일, Local은 콘솔, Prod는 엘라스틱 서치나 스플렁크와 같은 검색 엔진, 로그 분석 시스템에 전달
- ELK 스택으로 한 곳에 로그 분석 시스템을 만들어 분석

### 1.5.12 Admin 프로세스: 시스템 유지 보수를 위한 일회성 프로세스

- 중간에 데이터를 수정해야 하는 프로그램이 필요함
- 일회성 프로그램

### **궁금한 것**

1. 마이크로 아키텍처 서비스의 경우 각 컴포넌트마다 별도의 DB를 사용하는 것인지?
    - Join 해야하는 경우 어떠한 방식으로 처리를 해야하는 것인지 → 데이터를 애플리케이션 상에서 조인처리해서 사용하는지
2. 마이크로 아키텍처 서비스에서의 트랜잭션은 필수적이지 않은건가?
3. 분산 트랜잭션을 적용하는 방법
    - 2-Phase Commit 패턴(2PC)
        - 고전적인 방법
    - Saga 패턴
        - 마이크로서비스간 이벤트를 주고 받아 특정 마이크로서비스에서 작업이 실패하면, 이전까지의 작업이 완료된 마이크로서비스에 보상 이벤트를 발행함으로써 원자성을 보장하는 패턴
        - 개수가 늘어나면 늘어날 수록 의존성 처리를 해줘야 함 - 코레오어그래피 패턴
          - 오케스트레이션 사가 패턴 → 오케스트레이션 서버가 별도로 있고 메시지 라우팅, 이벤트 스토어 기능을 제공
    - Axon 프레임워크
        - 자바 기반의 오픈소스 프레임워크
        - Axon 서버는 메시징, 이벤트 저장 및 배포를 관리하는 독립 실행형 서버
        - CQRS 패턴을 기반으로 처리함
4. 프로세스를 이용해서 동시성을 관리하는 것은 어떤 것일까? -> 단순히 Scale Out 상황에서의 여러 프로세스가 동시성을 관리한다 라는 뜻인 것 같음

사실상 분산 트랜잭션을 적용해야한다는거 자체가 잘못된게 아닐까에 대한 의문도 있음 -> 어쨌든 데이터의 정합성이 중요한 서비스들은 MSA로 분리할 때 트랜잭션에 맞게 서비스를 분리해야하지 않을까? 분산 트랜잭션의 비용이 너무 들면 이것도 성능 저하에 많이 미칠 것 같음