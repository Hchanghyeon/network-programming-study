## NamedLock 테스트

### 1. 네임드락을 비즈니스 로직과 같이 트랜잭션 안에서 동작시킬 때

- 이 경우에는 네임드락이 해제 된 이후 쿼리가 나갈 수 있기 때문에 동시성 처리가 정상적으로 작동하지 않는 문제가 있음 (JPA 쓰기 지연)

### 2. 네임드락을 사용하는 트랜잭션과 비즈니스 로직의 트랜잭션을 분리하기(REQUIRES_NEW)

- 1번에서 문제가 되어 물리적으로 트랜잭션을 분리하여 비즈니스 로직의 트랜잭션이 끝난 이후 네임드락의 트랜잭션이 끝나게해서 락을 해제하기
- 네임드 락은 세션을 통해 락을 유지하며 세션이 끊기면 락을 해제하기 때문에 트랜잭션의 유지가 필요함
- 하지만 이 방식의 문제점으로는 동일한 데이터 소스를 사용하기 때문에 동시에 수 많은 요청이 한꺼번에 들어오면 락을 잡는데 커넥션 풀을 모두 다 사용해버려서 비즈니스 로직을 처리할 수 없게 됨(데드락)

### 3. 네임드락을 사용하는 트랜잭션과 비즈니스 로직의 트랜잭션을 분리하고, 데이터 소스를 분리하는 경우

- 데이터 소스를 아무리 분리하더라도, 트랜잭션 매니저에 의해 @Transactional은 기본 트랜잭션 매니저를 불러오므로 정상적인 작동을 기대하기 힘듦

### 4. 네임드락을 사용하는 트랜잭션과 비즈니스 로직의 트랜잭션을 분리하고, 데이터 소스를 분리하고 트랜잭션 매니저까지 분리하는 경우

- 트랜잭션 매니저까지 분리하더라도 정상적인 작동을 기대할 수 없었음
- 그 이유로는, 어쨌든 데이터 소스를 분리하고 트랜잭션 매니저까지 분리했으면 실행되는 락과 비즈니스 로직의 트랜잭션이 완전히 분리가 되어버림
- 결국 그 두개의 트랜잭션은 별 개의 트랜잭션이기 때문에 비즈니스 로직이 끝나기도전에 락이 해제될 수도 있고 네임드 락에 대해 공유하지 않기 때문에 전혀 상관 없는 트랜잭션이라고 판단함

## 결론
- 완벽하게 NamedLock을 사용하기 어렵다. flush()를 통해 최대한 트랜잭션 안에서 쿼리 문을 전부 다 끝내버리게 하고 네임드 락을 해제하는 방식으로 처리한다.
- 동일한 데이터 소스를 바라보고 트랜잭션을 수행하게 하되 커넥션 풀의 개수를 늘리자. 한꺼번에 너무 많은 사용자들이 접근하는 로직의 경우 네임드락을 사용하면 데드락 발생 가능성이 있으므로 다른 분산락(Redis)을 추천한다.
